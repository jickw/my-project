#-*-coding:utf-8-*-
"""
__title__ = ''
__author__ = 'wux'
__mtime__ = '2018/12/13'
"""

"""
A(B,C,D)
首先找到A继承的三个类的深度继承顺序，放到一个列表中
L[B] = [B,D,F,H]
L[C] = [C,E,G,H]
L[D] = [D,F,H]

第二步： A自己的广度，第一层
L[A] = [B,C,D]

[B,C,D,F,E,G,H]

每个列表的第一个元素为头部，从第一个列表的头部开始找，找到其他列表中尾部是否含有这个类名，如果没有，提取出来放到一个列表中，如果有
找下一个列表的头部，循环下去，只要提取出来一个，我们就从第一个列表的头部接着重复上面的操作
1  [B,D,F,H]   [C,E,G,H]  [D,F,H]   [B,C,D]
2   [D,F,H] [C,E,G,H]   [D,F,H] [C,D]
3   [D,F,H] [E,G,H]   [D,F,H] [D]
[F,H]  [E,G,H]  [F,H] []
因为第一个列表的D在其他列表的尾部存在，所以跳过D，然后找第二个列表的头部C，然后将其他列表头部的B删除，将B放到list中

4   [H] [H] [H] [] 
"""

